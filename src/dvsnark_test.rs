//! Includes tests for dvsnark prover-verifier
//!
//! [`test_dvsnark_prover_over_toy_r1cs`] runs the entire set of steps for a toy R1CS
//!
//! [`test_dvsnark_prover_over_sp1_r1cs`] runs the entire set of steps for an R1CS generated by SP1 zkvm. This requires
//! downloading some artifacts -- r1cs constraints, valid witness and vanishing polynomial coefficients (i.e. artifacts::DOMAIN_SPECIFIC_PRECOMPUTES for efficiency)
//! Therfore this test is marked as `ignored` for now.

#[cfg(test)]
mod tests {

    use crate::artifacts::{R1CS_CONSTRAINTS_FILE, R1CS_WITNESS_FILE};
    use crate::curve::Fr;
    use crate::proving::{Proof, prover_prepares_precomputes};
    use anyhow::Context;
    use ark_ff::Field;
    use ark_std::vec::Vec;
    use std::path::Path;

    use crate::gnark_r1cs::{load_witness_from_file, write_sparse_r1cs_to_file};

    use crate::gnark_r1cs::{Row, SparseR1CSTable, Term};
    use crate::srs::{SRS, Trapdoor};

    use ark_std::rand::SeedableRng;

    use rand_chacha::ChaCha20Rng;
    use std::time::Instant;

    use ark_ff::UniformRand;
    use ark_ff::{BigInteger, PrimeField};

    // dump toy constraints
    fn create_five_constraint_dump_on_a_file(cache_dir: &Path) {
        fn create_five_constraint_dump() -> SparseR1CSTable {
            /// Encode an `Fr` as canonical **big-endian** 32-byte array
            fn fr_to_be_bytes(x: Fr) -> [u8; 32] {
                let mut out = [0u8; 32];
                x.into_bigint()
                    .to_bytes_be()
                    .iter()
                    .rev()
                    .enumerate()
                    .for_each(|(i, b)| out[31 - i] = *b);
                out
            }

            /// Constant wires used below
            const WIRE_ONE: u32 = 0; // the “1” wire
            const WIRE_O: u32 = 1;
            const WIRE_W: u32 = 2;
            const WIRE_Y: u32 = 3;
            const WIRE_Z: u32 = 4;
            const WIRE_X: u32 = 5;
            const WIRE_T: u32 = 6;
            const WIRE_S: u32 = 7;

            // --------------------------------------------------------------------
            // Coefficient table  (index ↔ value)
            //   0 → 1
            //   1 → 2
            // --------------------------------------------------------------------
            let coeff_table = vec![
                fr_to_be_bytes(Fr::ONE),        // cid = 0
                fr_to_be_bytes(Fr::from(2u64)), // cid = 1
            ];

            // Convenience closures
            let c1 = |w: u32| Term {
                wire_id: w,
                coeff_id: 0,
            }; // coeff = 1
            let c2 = |w: u32| Term {
                wire_id: w,
                coeff_id: 1,
            }; // coeff = 2

            // --------------------------------------------------------------------
            // Constraint rows  (L, R, O)
            // --------------------------------------------------------------------

            let rows = vec![
                // c1:  x · x  = y
                Row {
                    l: vec![c1(WIRE_X)],
                    r: vec![c1(WIRE_X)],
                    o: vec![c1(WIRE_Y)],
                },
                // c2:  (y + z) · 1  = w
                Row {
                    l: vec![c1(WIRE_Y), c1(WIRE_Z)],
                    r: vec![c1(WIRE_ONE)],
                    o: vec![c1(WIRE_W)],
                },
                // c3:  (2·z) · 1  = t
                Row {
                    l: vec![c2(WIRE_Z)], // coeff 2
                    r: vec![c1(WIRE_ONE)],
                    o: vec![c1(WIRE_T)],
                },
                // c4:  (x + t) · 1  = s
                Row {
                    l: vec![c1(WIRE_X), c1(WIRE_T)],
                    r: vec![c1(WIRE_ONE)],
                    o: vec![c1(WIRE_S)],
                },
                // c5:  (w + s) · 1  = o
                Row {
                    l: vec![c1(WIRE_W), c1(WIRE_S)],
                    r: vec![c1(WIRE_ONE)],
                    o: vec![c1(WIRE_O)],
                },
            ];

            SparseR1CSTable {
                coeff_table,
                indices_rows: rows,
            }
        }

        let table: SparseR1CSTable = create_five_constraint_dump();
        std::fs::create_dir_all(cache_dir) // ensure directory exists
            .with_context(|| format!("creating {}", cache_dir.display()))
            .unwrap();
        let file_path = cache_dir.join(R1CS_CONSTRAINTS_FILE);
        let mut file = std::fs::File::create(file_path.clone()).unwrap();
        write_sparse_r1cs_to_file(&mut file, &table).unwrap();
    }

    #[test]
    fn test_dvsnark_prover_over_toy_r1cs() {
        let cache_dir = "srs_verifier_small_tmp";

        create_five_constraint_dump_on_a_file(Path::new(cache_dir));

        // witness that satisfies constraints
        let x = Fr::from(3u64);
        let y = x * x; // x^2 = 9
        let z = Fr::from(4u64);
        let w = y + z; // 9 + 4 = 13
        let t = z + z; // 2*z = 8
        let s = x + t; // 3 + 8 = 11
        let o = w + s; // 13 + 11 = 24

        // public and private inputs
        let public_inputs: Vec<Fr> = vec![o, w];
        let witness = vec![y, z, x, t, s];

        let mut rng = ChaCha20Rng::seed_from_u64(43);
        let trapdoor = Trapdoor {
            tau: Fr::rand(&mut rng),
            delta: Fr::rand(&mut rng),
            epsilon: Fr::rand(&mut rng),
        };

        // Run SRS setup assuming nothing is precomputed
        let _ = SRS::verifier_runs_fresh_setup(trapdoor, Path::new(cache_dir), public_inputs.len())
            .unwrap();

        // Prover precomputes stuff he needs for proving
        // These precomputes can be reused for different proof generations
        prover_prepares_precomputes("srs_verifier_small_tmp").unwrap();

        // Prover generates proof
        let proof = Proof::prove("srs_verifier_small_tmp", public_inputs.clone(), &witness);

        // Designated verifier verifies proof
        let public_inputs: Vec<Fr> = vec![o, w];
        let result = SRS::verify("srs_verifier_small_tmp", trapdoor, &public_inputs, &proof);
        assert!(
            result,
            "Verification should succeed for valid multi-constraint witness"
        );
    }

    #[test]
    #[ignore]
    fn test_dvsnark_prover_over_sp1_r1cs() {
        let cache_dir = "srs_secu";
        let now = Instant::now();
        let num_public_inputs = 2;

        // Load witness from file dumped by sp1 gnark
        // Witness is known to have the format [1, ...public_inputs, ...private_inputs]
        let wit_fr: Vec<Fr> = load_witness_from_file(&format!("{cache_dir}/{R1CS_WITNESS_FILE}"));
        assert_eq!(wit_fr[0], Fr::ONE);
        let priv_fr = wit_fr[1 + num_public_inputs..].to_vec();
        let public_inputs = wit_fr[1..1 + num_public_inputs].to_vec();

        let mut rng = ChaCha20Rng::seed_from_u64(41);

        let elapsed = now.elapsed();
        println!("Took {} seconds to load R1CS witness", elapsed.as_secs());
        let now = Instant::now();

        let trapdoor = Trapdoor {
            tau: Fr::rand(&mut rng),
            delta: Fr::rand(&mut rng),
            epsilon: Fr::rand(&mut rng),
        };

        // verifier runs setup assuming `artifacts::DOMAIN_SPECIFIC_PRECOMPUTES` are present inside `cache_dir`
        let _ = SRS::verifier_runs_setup_with_precompute(trapdoor, cache_dir, num_public_inputs)
            .unwrap();

        let elapsed = now.elapsed();
        println!("Took {} seconds to setup SRS", elapsed.as_secs());

        // prover generates precomputes and also downloads `artifacts::DOMAIN_SPECIFIC_PRECOMPUTES` inside his `cache_dir`
        let now = Instant::now();
        prover_prepares_precomputes(cache_dir).unwrap();
        let elapsed = now.elapsed();
        println!("Took {} seconds to precompute SRS", elapsed.as_secs());

        let now = Instant::now();
        // prover generates proof
        let proof = Proof::prove(cache_dir, public_inputs.clone(), &priv_fr);

        let elapsed = now.elapsed();
        println!("Took {} seconds to generate proof", elapsed.as_secs());
        let now = Instant::now();

        // Designated verifier verifies proof
        let result = SRS::verify(cache_dir, trapdoor, &public_inputs, &proof);
        let elapsed = now.elapsed();
        println!("Took {} seconds to verify proof", elapsed.as_secs());

        assert!(
            result,
            "Verification should succeed for valid multi-constraint witness"
        );
    }
}
